=FST - Fast Serialization Thingy=

==Quick Start==

===Plain {{{ObjectOutputStrem}}} Replacement Usage ===

{{{
...
// ! reuse this Object, it caches metadata. Performance degrades massively
// if you create a new Configuration Object with each serialization !
static FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
...
public MyClass myreadMethod( InputStream stream ) {
    FSTObjectInput in = new FSTObjectInput(stream,conf);
    MyClass result = (MyClass)in.readObject();
    in.close();
    return result;
}

public void mywriteMethod( OutputStream stream, MyClass toWrite ) {
    FSTObjectOutput out = new FSTObjectOutput(stream,conf);
    out.writeObject( toWrite );
    out.close();
}
}}}

if you know the type of the Object (saves some bytes for the class name of the initial Object) you can do:
{{{
...
// ! reuse this Object, it caches metadata. Performance degrades massively
// if you create a new Configuration Object with each serialization !
static FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
...
public MyClass myreadMethod(InputStream stream) {
    FSTObjectInput in = new FSTObjectInput(stream,conf);
    MyClass result = in.readObject(MyObject.class);
    in.close();
    return result;
}

public void mywriteMethod( OutputStream stream, MyClass toWrite ) {
    FSTObjectOutput out = new FSTObjectOutput(stream, conf);
    out.writeObject( toWrite, toWrite.getClass() );
    out.close();
}
}}}
Note that if you write with a type, you also have to read with a type !


Basically you just replace the {{{ObjectOutputStream, ObjectInputStream}}} with {{{FSTObjectOutput,FSTObjectInput}}}
In case of *multi-threaded* usage you have to create a distinct FSTConfiguration Object for each reading/writing Thread. (This will probably change with a newer version). Maybe use a {{{ThreadLocal}}} variable to hold/cache a FSTConfiguration.