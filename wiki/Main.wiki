=FST - Fast Serialization Thingy=

==Quick Start==

*Plain {{{ObjectOutputStream}}} Replacement Usage *

{{{
...
// ! reuse this Object, it caches metadata. Performance degrades massively
// if you create a new Configuration Object with each serialization !
static FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
...
public MyClass myreadMethod( InputStream stream ) {
    FSTObjectInput in = new FSTObjectInput(stream,conf);
    MyClass result = (MyClass)in.readObject();
    in.close();
    return result;
}

public void mywriteMethod( OutputStream stream, MyClass toWrite ) {
    FSTObjectOutput out = new FSTObjectOutput(stream,conf);
    out.writeObject( toWrite );
    out.close();
}
}}}

if you know the type of the Object (saves some bytes for the class name of the initial Object) you can do:
{{{
...
// ! reuse this Object, it caches metadata. Performance degrades massively
// if you create a new Configuration Object with each serialization !
static FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
...
public MyClass myreadMethod(InputStream stream) {
    FSTObjectInput in = new FSTObjectInput(stream,conf);
    MyClass result = in.readObject(MyObject.class);
    in.close();
    return result;
}

public void mywriteMethod( OutputStream stream, MyClass toWrite ) {
    FSTObjectOutput out = new FSTObjectOutput(stream, conf);
    out.writeObject( toWrite, toWrite.getClass() );
    out.close();
}
}}}
Note that if you write with a type, you also have to read with a type !


Basically you just replace the {{{ObjectOutputStream, ObjectInputStream}}} with {{{FSTObjectOutput,FSTObjectInput}}}.


In case of *multi-threaded* usage you have to create a distinct FSTConfiguration Object for each reading/writing Thread. (This will probably change with a newer version). Maybe use a {{{ThreadLocal}}} variable to hold/cache a FSTConfiguration.


Large Objects / chunked IO

Note that the Object is written to the undelying stream once you close the FSTOutputStream. Vice versa, the FSTInput reads the full stream until it starts decoding. This speed up i/o, however later versions will introduce a block mode / streaming facility. This may also be a problem in case you read/write very large Objects.
A work around in the current version would be to write you Objects chunked (e.g. if you have a List of Objects to serialize, create a new FSTObjectOutput for each Object of the list). Usually allocating some 100 kByte (or even MB) of byte arrays should not be a problem, I just mention this limitation in case you are reading/writing huge Object Trees or you are trying to stream an ObjectGraph in small chunks.