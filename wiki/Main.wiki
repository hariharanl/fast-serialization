=FST - Fast Serialization Thingy=

==Quick Start==


*Plain {{{ObjectOutputStream}}} Replacement Usage *

{{{
...
// ! reuse this Object, it caches metadata. Performance degrades massively
// if you create a new Configuration Object with each serialization !
static FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
...
public MyClass myreadMethod( InputStream stream ) {
    FSTObjectInput in = new FSTObjectInput(stream,conf);
    MyClass result = (MyClass)in.readObject();
    in.close();
    return result;
}

public void mywriteMethod( OutputStream stream, MyClass toWrite ) {
    FSTObjectOutput out = new FSTObjectOutput(stream,conf);
    out.writeObject( toWrite );
    out.close();
}
}}}

if you know the type of the Object (saves some bytes for the class name of the initial Object) you can do:
{{{
...
// ! reuse this Object, it caches metadata. Performance degrades massively
// if you create a new Configuration Object with each serialization !
static FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
...
public MyClass myreadMethod(InputStream stream) {
    FSTObjectInput in = new FSTObjectInput(stream,conf);
    MyClass result = in.readObject(MyObject.class);
    in.close();
    return result;
}

public void mywriteMethod( OutputStream stream, MyClass toWrite ) {
    FSTObjectOutput out = new FSTObjectOutput(stream, conf);
    out.writeObject( toWrite, toWrite.getClass() );
    out.close();
}
}}}
Note that if you write with a type, you also have to read with a type !


Basically you just replace the {{{ObjectOutputStream, ObjectInputStream}}} with {{{FSTObjectOutput,FSTObjectInput}}}.

_Multi threaded read/write_

In case of multi-threaded usage you have to create a distinct FSTConfiguration Object for each reading/writing Thread. (This will probably change with a newer version). Maybe use a {{{ThreadLocal}}} variable to hold/cache a FSTConfiguration.



_Huge Objects / chunked,streaming I/O:_

The Object is written to the underlying stream once you close the FSTOutputStream. Vice versa, the FSTInput reads the full stream until it starts decoding. 

This may be a problem in case you read/write huge Objects or want to stream an ObjectGraph in small chunks.

A work around in the current version would be to write your Objects chunked (e.g. if you have a List of Objects to serialize, create a new FSTObjectOutput for each Object of the list). Usually allocating some 100 kByte (or even MB) of byte arrays should not be a problem, I just mention this limitation in case you plan reading/writing huge Object Trees or you are trying to stream an ObjectGraph in small chunks.


*Using conditional Decoding*

There are scenarios (e.g. when using multicast), where not every receiver needs to decode all received Objects. In a high performance environment you then like to decode only Objects/Messages you are interested in. With FST you can achieve that using the @Conditional annotation.

{{{
class ConditionalExample {
   int messagetype;

   @Conditional
   BigObject aBigObject;

...
}
}}}

if you read the Object, do the following:
{{{
        FSTObjectInput.ConditionalCallback conditionalCallback = new FSTObjectInput.ConditionalCallback() {
            @Override
            public boolean shouldSkip(Object halfDecoded, int streamPosition, Field field) {
                return ((ConditionalExample)halfDecoded).messagetype != 13;
            }
        };
        ...
        ...
        FSTObjectInput fstin = new FSTObjectInput(instream, conf);
        fstin .setConditionalCallback(conditionalCallback);
        Object res = in.readObject(cl);


}}}

The {{{FSTObjectInput}}} will deserialize all fields of {{{ConditionalExample}}} then call 'shouldSkip' giving in the partially-deserialized Object. If the shouldSkip method returns false, the @Conditional reference will be decoded and set, else it will be skipped.