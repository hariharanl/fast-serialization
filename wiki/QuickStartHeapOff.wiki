<p lign=right>_FST - Fast Serialization Thingy_</p>
----

*What is Heap-Offloading ?*

Usually all non-temporary objects you allocate are managed by java's garbage collector. Although the VM does a decent job doing garbage collection, at a certain point the VM has to do a so called 'Full GC'. A full GC involves scanning the complete allocated Heap, which means GC pauses/slowdowns are proportional to an applications heap size. So don't trust any person telling you 'Memory is Cheap'. In java memory consumtion hurts performance. Additionally you may get notable pauses using heap sizes > 1 Gb. This can be nasty if you have any near-real-time stuff going on, additioinally in cluster's or grid's a java process might get unresponsive and dropped from the cluster.

However todays server applications (frequently built on top of bloaty frameworks ;-) ) easily require heaps far beyond 4Gb.

One *solution* to these memory requirements, is to 'offload' parts of the objects to the non-java heap (directly allocated from the OS).
Fortunately java.nio provides classes to directly allocate/read and write 'unmanaged' chunks of memory (even memory mapped files).

So one can allocate large amounts of 'unmanaged' memory and use this to save objects there. In order to save arbitrary objects into memory, the most viable solution is the use of Serialization. 
This means the application serializes objects into the offheap memory, later on the object can be read using deserialization.

It is clear, that *the performance of such an off heap buffer depends mostly on the performance of the serialization implementation*.

FST encapsulates the low level stuff by providing 2 classes:

  * {{{FSTOffheap}}} - a simple off heap collection. One can add objects and search the collection using an iterator. Additionally each object can be saved with a tag object to speed up linear search later on.
  * {{{FSTOffHeapMap}}} - an implementation of Map, which puts its value Objects to directly allocated 'native' memory.


Sample usage scenarios:
  * Session cache in a servler application. Use a memory mapped file to store gigabytes of (inactive) user sessions. Once the user logs into your application, you can quickly access user-related data without having to deal with a database.
  * Caching of computational results (queries, html pages, ..) (only applicable if computation is slower than deserializing the result object ofc).