#labels Featured
<p lign=right>_FST - Fast Serialization_</p>
----

*What is Heap-Offloading ?*

Usually all non-temporary objects you allocate are managed by java's garbage collector. Although the VM does a decent job doing garbage collection, at a certain point the VM has to do a so called 'Full GC'. A full GC involves scanning the complete allocated Heap, which means GC pauses/slowdowns are proportional to an applications heap size. So don't trust any person telling you 'Memory is Cheap'. In java memory consumtion hurts performance. Additionally you may get notable pauses using heap sizes > 1 Gb. This can be nasty if you have any near-real-time stuff going on, in a cluster or grid a java process might get unresponsive and get dropped from the cluster.

However todays server applications (frequently built on top of bloaty frameworks ;-) ) easily require heaps far beyond 4Gb.

One *solution* to these memory requirements, is to 'offload' parts of the objects to the non-java heap (directly allocated from the OS).
Fortunately java.nio provides classes to directly allocate/read and write 'unmanaged' chunks of memory (even memory mapped files).

So one can allocate large amounts of 'unmanaged' memory and use this to save objects there. In order to save arbitrary objects into unmanaged memory, the most viable solution is the use of Serialization. 
This means the application serializes objects into the offheap memory, later on the object can be read using deserialization.

The heap size managed by the java VM can be kept small, so GC pauses are in the millis, everybody is happy, job done.

It is clear, that *the performance of such an off heap buffer depends mostly on the performance of the serialization implementation*. Good news: for some reason FST-serialization is pretty fast :-).

FST encapsulates the low level stuff by providing 2 classes:

  * {{{FSTOffheap}}} - a simple off heap collection. One can add objects and search the collection using an iterator. Additionally each object can be saved with a tag object to speed up linear search later on.
  * {{{FSTOffHeapMap}}} - an implementation of Map, which puts its value Objects to directly allocated 'native' memory.


Sample usage scenarios:
  * Session cache in a server application. Use a memory mapped file to store gigabytes of (inactive) user sessions. Once the user logs into your application, you can quickly access user-related data without having to deal with a database.
  * Caching of computational results (queries, html pages, ..) (only applicable if computation is slower than deserializing the result object ofc).
  * very simple and fast persistance using memory mapped files


<br><br>
*What performance to expect ?*

For benchmarking I use a somewhat typical enterprise bloat object using finegrained data type classes. {{{ObjectOrientedDataType}}} consists of a string and a boolean, {{{ObjectOrientedInt}}} wrappes an int.

{{{
public class SimpleOrder implements Serializable {

    Date mOrderTime;
    ObjectOrientedDataType mTradableId;
    ObjectOrientedDataType mTraderId;
    ObjectOrientedDataType mBuySell;
    ObjectOrientedDataType mOrderType;
    ObjectOrientedInt mOrderQty;
    ObjectOrientedInt mInitialOrderQty;
    ObjectOrientedInt mOrderPrc;
    Long mOrderId;
    ObjectOrientedDataType mText;
}
}}}

benchmark reading/writing 4 millions of those objects (FST v0.7):
http://fast-serialization.googlecode.com/files/offheap-0.8.html

As one can see, performance of off-heap storage is far slower than Java-Heap storage. However it is much faster than using other methods to move  bigdata outside the VM (Databases etc.). It is clear that an applications needs some kind of indexing in order to access the data, straight forward search will not be fast enough in most cases.
However accessing (and deserializing) a stored Object *within 3.5 microseconds* (=284 per ms) is decent and much faster than any kind of other storage methods except the built in java heap.

* FST Offheap classes *

*{{{FSTOffHeap}}}*

Basic Offheap store. It allocates a chunk of memory and allows to add Objects to it. Objects cannot be removed.
In order to allow searching/iterating, one can associate a "tag" object with each entry (e.g. {{{offheap.add(person, person.getName()}}} ). When iterating tag-wise, only the tag is deserialized, so it is possible to search quicker only deserializing the tag object (note its an extended subclass of iterator). The heap store does not grow automatically. 
Each add() returns an int handle which can be used to obtain the stored object later on.

By initializing {{{FSTOffHeap}}} with a memory mapped file buffer, one may use this class to write to files.

_multi threading_

The add methods directly avaiable at the offheap class are not thread safe, to get thread safe access use the getAccess() method. using a distinct access object for each concurrent thread accessing the buffer is thread safe. Iteration is thread safe also.

This is only a basic building block for higher level functionality (e.g. offheap queue and offheap map).