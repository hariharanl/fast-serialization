#FST struct emulation

= Introduction =

_In C++, one needs to sacrifice performance in order to get convenience, in Java one needs to sacrifice convenience in order to get performance_


While serialization can flatten any Object Graph into a byte array, one needs to deserialize the Object in order to access the data contained. Frequently (offheap objects, locality) one would like to access the data without the costly "deserialization"-part.

FSTStructs provide a way to store and access data in a deterministic structured layout in a continuous chunk of memory.
I therefore use runtime byte code generation and (may change in future) the Unsafe class in order to redirect member access inside methods to an underlying {{{byte[]}}}} array.

While there are a lot compromises to be made (a clean, orthogonal implementation would require VM extensions) when defining FSTStructs, there are a lot of benefits when "flattening" data structures in a still accessible way:

  * very low GC cost (store GB of structured data with <10ms Full GC duration) 
  * (un-)marshalling is equal to a memory copy. This speeds up inter process communication using shared memory or network messages.
  * use memory mapped files to virtually enlarge your memory, as it is possible to control memory layout of your data
  * faster iteration of complex data structures compared to On-Heap due to control over in memory layout and "pointer-alike" memory access patterns
  * data structures can be de/encoded easy from external languages


https://fast-serialization.googlecode.com/files/structlayout.PNG

==How does this work ?==

Structs are stored in byte arrays, additionally FST generates "pointer"-alike Wrapper Classes at runtime providing access to the flattened objects inside the byte array. One could put an arbitrary number of struct instances into a single byte array.

Technically FST separates object header and instance fields. So the data of an object is stored inside a flat byte[]. In order to access the data, an accessor instance pointing to the embedded data has to be created. By moving the address-pointer of such an accessor class (generated at runtime) one can use a single instance to read different datasets stored in the flat byte array. FST has a per-thread cache of those wrappers (i call them pointer) in order to enable transparent access to structures and embedded substructures.

Code Examples:
{{{
        
        // build template
        TestInstrument template = new TestInstrument();
        // max 4 legs
        template.legs = new TestInstrumentLeg[] { new TestInstrumentLeg(), null, null, null };
        FSTStructAllocator<TestInstrument> alloc = 
             new FSTStructAllocator<TestInstrument>(template,SIZE);

        StructArray<TestInstrument> instruments = alloc.newArray(100000);

}}} 

results in a flat array of in-place copies of the given "template" instance. One can access this like usual object structures like

{{{
        sum = 0;
        for ( int i = 0; i < instruments.size(); i++ ) {
            sum+=instruments.get(i).getAccumulatedQty();
        }
}}}

In order to pass a structure embedded object to outer code, a 'pointer' (accessor class instance) must be created. FST Byte code instrumentation automatically creates and caches those 'accessor classes'. However if you want to 'keep' (assign) such a struct object, a call to 'detach()' is required. Else subsequent calls will point your accessor to another instance (accessors are reused).


{{{
        TestInstrumentLeg toDetach = instruments.get(i).legs(1);
        toDetach.detach();
        otherCode(toDetach);
}}}

Embedded Objects can be rewritten, however one gets an exception if the new object requires more bytes than the previous. 

some benchmarks:
https://fast-serialization.googlecode.com/files/structiter.html

== Rules for structable classes ==

  * a structable class has to inherit FSTStruct
  * a structable class can only reference FSTStruct and subclasses. It is not possible to have references from within a struct to a heap object.
  * all fields and methods must be non-final public or proteced. (required to enable instrumentation)
  * no direct references to embedded arrays are allowed. You have to create array accessor methods following a defined naming pattern.
  * no support for arrays of arrays (multidimensional) within structs 
  * all sizings are determined at instantiation time, this also applies to strings. {{{StructStrings}}} are fixed size.
  * there are several method naming schemes which are recognized by FST byte code instrumentation. This way it is possible to e.g. get the base index of an embedded int array in case.