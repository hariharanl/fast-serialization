#FST struct emulation

= Introduction =

_In C++, one needs to sacrifice performance in order to get convenience, in Java one needs to sacrifice convenience in order to get performance_


While serialization can flatten any Object Graph into a byte array, a disadvantage is that you need to deserialize the Object in order to access the data. However frequently (offheap objects, locality) one would like to access the data without the costly "decoding" part.

FSTStructs provide a way to store and access data in a deterministic structured layout in a continuous chunk of memory.
I therefore use runtime byte code generation and (may change in future) the Unsafe class in order to redirect direct member access of a methods code to a {{{byte[]}}}} array.

While there are a lot compromises to be made (an orthogonal implementation would require VM extensions) when defining FSTStructs, there are a lot of benefits "flattening" data structures:

  * very low GC cost (store GB of structured data with <10ms Full GC duration) 
  * (un-)marshalling is equal to a memory copy. This speeds up inter process communication using shared memory or network messages.
  * use memory mapped files to virtually enlarge your memory, as it is possibble to control memory layout of your data
  * faster iteration of complex data structures compared to On-Heap due to control over in memory layout and "pointer-alike" memory access patterns


= Details =

Add your content here.  Format your content with:
  * Text in *bold* or _italic_
  * Headings, paragraphs, and lists
  * Automatic links to other wiki pages