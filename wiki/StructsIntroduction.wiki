#FST struct emulation

= Introduction =

_In C++, one needs to sacrifice performance in order to get convenience, in Java one needs to sacrifice convenience in order to get performance_


While serialization can flatten any Object Graph into a byte array, one needs to deserialize the Object in order to access the data contained. Frequently (offheap objects, locality) one would like to access the data without the costly "deserialization"-part.

FSTStructs provide a way to store and access data in a deterministic structured layout in a continuous chunk of memory.
I therefore use runtime byte code generation and (may change in future) the Unsafe class in order to redirect member access inside methods to an underlying {{{byte[]}}}} array.

While there are a lot compromises to be made (a clean, orthogonal implementation would require VM extensions) when defining FSTStructs, there are a lot of benefits when "flattening" data structures in a still accessible way:

  * very low GC cost (store GB of structured data with <10ms Full GC duration) 
  * (un-)marshalling is equal to a memory copy. This speeds up inter process communication using shared memory or network messages.
  * use memory mapped files to virtually enlarge your memory, as it is possible to control memory layout of your data
  * faster iteration of complex data structures compared to On-Heap due to control over in-memory layout (locality!) and "pointer-alike" memory access patterns
  * data structures can be de/encoded easy from external languages


https://fast-serialization.googlecode.com/files/structlayout.PNG

==How does this work ?==

Structs are stored in byte arrays, additionally FST generates "pointer"-alike Wrapper Classes at runtime providing access to the flattened objects inside the byte array. One could put an arbitrary number of struct instances into a single byte array.

Technically FST separates object header and instance fields. So the data of an object is stored inside a flat byte[]. In order to access the data, an accessor instance pointing to the embedded data has to be created. By moving the address-pointer of such an accessor class (generated at runtime) one can use a single instance to read different datasets stored in the flat byte array. FST has a per-thread cache of those wrappers (i call them pointer) in order to enable transparent access to structures and embedded substructures.

Code Examples:
{{{
        
        // build template
        TestInstrument template = new TestInstrument();
        // max 4 legs
        template.legs = new TestInstrumentLeg[] { new TestInstrumentLeg(), null, null, null };
        FSTStructAllocator<TestInstrument> allocator = 
             new FSTStructAllocator<TestInstrument>(template,SIZE);

        StructArray<TestInstrument> instruments = allocator.newArray(100000);

}}} 

results in a flat array of in-place copies of the given "template" instance. One can access this like usual object structures like

{{{
        sum = 0;
        for ( int i = 0; i < instruments.size(); i++ ) {
            sum+=instruments.get(i).getAccumulatedQty();
        }
}}}

In order to pass a structure embedded object to outer code, a 'pointer' (accessor class instance) must be created. FST Byte code instrumentation automatically creates and caches those 'accessor classes'. However if you want to 'keep' (assign) such a struct object, a call to 'detach()' is required. Else subsequent calls will point your accessor to another instance (accessors are reused).


{{{
        TestInstrumentLeg toDetach = instruments.get(i).legs(1);
        toDetach.detach();
        otherCode(toDetach);
}}}

Embedded Objects can be rewritten, however one gets an exception if the new object requires more bytes than the previous. 

some benchmarks:
https://fast-serialization.googlecode.com/files/structiter.html

== Rules for structable classes ==

  * a structable class has to inherit FSTStruct
  * no direct public field access possible. You need to use getter/setter methods. This does not apply for member methods.
  * a structable class can only contain fields that reference FSTStruct and subclasses or primitives. It is not possible to have references from within a struct to a heap object.
  * all fields and methods must be non-final public or proteced. (required to enable instrumentation)
  * no direct references to embedded arrays are allowed. You have to create array accessor methods following a defined naming pattern.
  * no support for arrays of arrays (multidimensional) within structs 
  * all sizings are determined at instantiation time, this also applies to strings. {{{StructStrings}}} are fixed size.
  * there are several method naming schemes which are recognized by FST byte code instrumentation. This way it is possible to e.g. get the base index of an embedded int array in case.
  * if you want to 'keep' a reference to an embedded object (store tmp variable in a loop or field) you need to call detach() on that reference
  * you cannot synchronize on embedded objects
  * the template object defining the layout and initial values of struct(s) must not contain cyclic references 
  * System.identityHashcode delivers the identity of the access wrapper, not the embedded object.

== Simple fields ==

primitive fields can be declared straight forward and can be accessed directly from method code.

{{{
public class SubStruct extends FSTStruct {
    StructString name = new StructString(30);
    int age = 42;
    ... getters / setters ommitted here ...
}

public class Example extends FSTStruct {

    protected int intField;
    protected double d = 66666666666.66;
    protected SubStruct sub = new SubStruct();

    public int getIntField() { return intField; }
    public void setIntField(int val) { intField = val; }

    public SubStruct getSub() { return sub ; }
    public void setSub(SubStruct val) { sub = val; }

    public void multiply(int mul) {
        // direct member access is OK inside your struct class (and subclasses)
        intField *= mul; 
    }

    public double getD() {
        return d;
    }

    public String toString() {
        return "Example if:"+intField+" d:"+d;
    }
}
}}}

Note, that this class is fully operable when allocated as usual on the heap.

if we create a struct array from that

{{{
    STStructAllocator<Example> allocator = 
             new FSTStructAllocator<Example>(new Example());

    StructArray<Example> exampleArray = allocator.newArray(1000000);

    Example onHeap = new Example();
    exampleArray.get(10).getIntField(); // get volatile pointer to 10't element and get intVal
    exampleArray.get(10).getSub().getName().setString("Me"); // rewrite StructString content
    exampleArray.get(10).getSub().setName( new StructString("You") ); // rewrite StructString object

}}}

we get an array of 1 million Example struct instances, initialzed as a copy of the template given by "new Example()". The difference is, that a "normal" implementation would have created 3.000.001 Objects (array and 1 million Example, 1 million substruct, 1 million structstring instances), which (if not temporary) will cost the garbage collector ~800 to 1250 ms to traverse.
The struct example actually allocates one large byte array, which will have practical no impact on GC duration. The data is 'hidden' from the Garbage Collector. 

*Important:* calling a setter on an struct's embedded object will *copy* the given object. When calling a setter on normal object, a reference will be stored. For structs, every set is "by value" not by reference. This is a technical necessity.

if you examine the (volatile) structpointer obtained by {{{exampleArray.get(10).getSub()}}} you will note, that the instance variables are null or 0. This is because FST instrumentation patches all accesses of the methods of 'Example' and redirects the read/write to the underlying byte array. This is not the case if you allocate it regular on the heap with {{{new}}}. 

*Important:* If you need a permanent reference, call 'detach()' on the volatile access wrapper:
{{{
    SubStruct sub = exampleArray.get(10).getSub();
    sub.detach();
}}}