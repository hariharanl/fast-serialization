<p lign=right>_FST - Fast Serialization Thingy_</p>
----

==Quick Start==


*Plain {{{ObjectOutputStream}}} Replacement Usage *

{{{
...
// ! reuse this Object, it caches metadata. Performance degrades massively
// if you create a new Configuration Object with each serialization !
static FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
...
public MyClass myreadMethod( InputStream stream ) {
    FSTObjectInput in = new FSTObjectInput(stream,conf);
    MyClass result = (MyClass)in.readObject();
    in.close();
    return result;
}

public void mywriteMethod( OutputStream stream, MyClass toWrite ) {
    FSTObjectOutput out = new FSTObjectOutput(stream,conf);
    out.writeObject( toWrite );
    out.close();
}
}}}

if you know the type of the Object (saves some bytes for the class name of the initial Object) you can do:
{{{
...
// ! reuse this Object, it caches metadata. Performance degrades massively
// if you create a new Configuration Object with each serialization !
static FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
...
public MyClass myreadMethod(InputStream stream) {
    FSTObjectInput in = new FSTObjectInput(stream,conf);
    MyClass result = in.readObject(MyObject.class);
    in.close();
    return result;
}

public void mywriteMethod( OutputStream stream, MyClass toWrite ) {
    FSTObjectOutput out = new FSTObjectOutput(stream, conf);
    out.writeObject( toWrite, toWrite.getClass() );
    out.close();
}
}}}
Note that if you write with a type, you also have to read with a type !


Basically you just replace the {{{ObjectOutputStream, ObjectInputStream}}} with {{{FSTObjectOutput,FSTObjectInput}}}.

_Multi threaded read/write_

In case of multi-threaded usage you have to create a distinct FSTConfiguration Object for each reading/writing Thread. (This will probably change with a newer version). Maybe use a {{{ThreadLocal}}} variable to hold/cache a FSTConfiguration.



_Huge Objects / chunked,streaming I/O:_

The Object is written to the underlying stream once you close the FSTOutputStream. Vice versa, the FSTInput reads the full stream until it starts decoding. 

This may be a problem in case you read/write huge Objects or want to stream an object graph in small chunks.

A work around in the current version would be to write your Objects chunked (e.g. if you have a List of Objects to serialize, create a new FSTObjectOutput for each Object of the list). Usually allocating some 100 kByte (or even MB) of byte arrays should not be a problem, I just mention this limitation in case you plan reading/writing huge Object Trees or you are trying to stream an object graph in small chunks.


*Using conditional Decoding*

There are scenarios (e.g. when using multicast), where a receiver conditionally wants to skip decoding parts of a received Object in order to save CPU time. With FST one can achieve that using the @Conditional annotation.

{{{
class ConditionalExample {
   int messagetype;

   @Conditional
   BigObject aBigObject;

...
}
}}}

if you read the Object, do the following:
{{{
        FSTObjectInput.ConditionalCallback conditionalCallback = new FSTObjectInput.ConditionalCallback() {
            @Override
            public boolean shouldSkip(Object halfDecoded, int streamPosition, Field field) {
                return ((ConditionalExample)halfDecoded).messagetype != 13;
            }
        };
        ...
        ...
        FSTObjectInput fstin = new FSTObjectInput(instream, conf);
        fstin .setConditionalCallback(conditionalCallback);
        Object res = in.readObject(cl);


}}}

The {{{FSTObjectInput}}} will deserialize all fields of {{{ConditionalExample}}} then call 'shouldSkip' giving in the partially-deserialized Object. If the shouldSkip method returns false, the @Conditional reference will be decoded and set, else it will be skipped.

*Using Custom Serializers*

By default FST falls back to the methods defined by the JDK. Especially if private methods like 'writeObject' are involved, performance suffers, because reflection must be used. Additionally the efficiency of some stock JDK classes is _cruel_ regarding size and speed. The FST default configuration ({{{FSTConfiguration.createDefaultConfiguration()}}}) already registers some serializers for common classes (popular Collections and some other frequently used classes).
So if you have trouble with stock JDK serilaization speed/efficiency, you might want to register a piece of custom code defining how to read and write an object of a specific class.

the basic interface is this
{{{
public interface FSTObjectSerializer {
    /**
     * write the contents of a given object
     */
    public void writeObject(FSTObjectOutput out, Object toWrite, FSTClazzInfo clzInfo, FSTClazzInfo.FSTFieldInfo referencedBy) throws IOException;

    /**
     * read the content to an already instantiated object
     */
    public void readObject(FSTObjectInput in, Object toRead, FSTClazzInfo clzInfo, FSTClazzInfo.FSTFieldInfo referencedBy) throws IOException, ClassNotFoundException, IllegalAccessException, InstantiationException;

    /**
     * useful if you register for a class and its subclasses, but want to exclude a specific subclass
     */
    public boolean willHandleClass(Class cl);

    /**
     * return null to delegate object instantiation to FST. If you want to implement object instantiation yourself, usually you leave the readObject method empty
     * and handle instantiation and reading the object here. You must call registerObject immediately after creating it on the FSTObjectInput
     */
    public Object instantiate(Class objectClass, FSTObjectInput fstObjectInput, FSTClazzInfo serializationInfo, FSTClazzInfo.FSTFieldInfo referencee, int streamPositioin) throws IOException, ClassNotFoundException, InstantiationException, IllegalAccessException;
}
}}}