#labels Featured
<p lign=right>_FST - Fast Serialization_</p>
----
==Quick Start==


*Plain {{{ObjectOutputStream}}} Replacement Usage *

Basically you just replace the {{{ObjectOutputStream, ObjectInputStream}}} with {{{FSTObjectOutput,FSTObjectInput}}}.
{{{
...
// ! reuse this Object, it caches metadata. Performance degrades massively
// if you create a new Configuration Object with each serialization !
static FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
...
public MyClass myreadMethod( InputStream stream ) {
    FSTObjectInput in = new FSTObjectInput(stream,conf);
    MyClass result = (MyClass)in.readObject();
    in.close();
    return result;
}

public void mywriteMethod( OutputStream stream, MyClass toWrite ) {
    FSTObjectOutput out = new FSTObjectOutput(stream,conf);
    out.writeObject( toWrite );
    out.close();
}
}}}

if you know the type of the Object (saves some bytes for the class name of the initial Object) you can do:
{{{
...
// ! reuse this Object, it caches metadata. Performance degrades massively
// if you create a new Configuration Object with each serialization !
static FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
...
public MyClass myreadMethod(InputStream stream) {
    FSTObjectInput in = new FSTObjectInput(stream,conf);
    MyClass result = in.readObject(MyClass.class);
    in.close();
    return result;
}

public void mywriteMethod( OutputStream stream, MyClass toWrite ) {
    FSTObjectOutput out = new FSTObjectOutput(stream, conf);
    out.writeObject( toWrite, MyClass.class );
    out.close();
}
}}}
Note that if you write with a type, you also have to read with the same type !


_Multi threaded read/write_

In case of multi-threaded usage you have to create a distinct FSTConfiguration Object for each reading/writing Thread. (This will probably change with a newer version). Maybe use a {{{ThreadLocal}}} variable to hold/cache a FSTConfiguration.



_Huge Objects / chunked,streaming I/O:_

The encoded Objects are written to the underlying stream once you close the FSTOutputStream. Vice versa, the FSTInput reads the full stream until it starts decoding. 

This may be a problem in case you read/write huge Objects or want to stream an object graph in small chunks.

A work around in the current version would be to write your Objects chunked (e.g. if you have a List of Objects to serialize, create a new FSTObjectOutput for each Object of the list). Usually allocating some 100 kByte (or even MB) of byte arrays should not be a problem, I just mention this limitation in case you plan reading/writing huge Object Trees or you are trying to stream an object graph in small chunks.


*Using conditional Decoding*

There are scenarios (e.g. when using multicast), where a receiver conditionally wants to skip decoding parts of a received Object in order to save CPU time. With FST one can achieve that using the @Conditional annotation.

{{{
class ConditionalExample {
   int messagetype;

   @Conditional
   BigObject aBigObject;

...
}
}}}

if you read the Object, do the following:
{{{
        FSTObjectInput.ConditionalCallback conditionalCallback = new FSTObjectInput.ConditionalCallback() {
            @Override
            public boolean shouldSkip(Object halfDecoded, int streamPosition, Field field) {
                return ((ConditionalExample)halfDecoded).messagetype != 13;
            }
        };
        ...
        ...
        FSTObjectInput fstin = new FSTObjectInput(instream, conf);
        fstin .setConditionalCallback(conditionalCallback);
        Object res = in.readObject(cl);


}}}

The {{{FSTObjectInput}}} will deserialize all fields of {{{ConditionalExample}}} then call 'shouldSkip' giving in the partially-deserialized Object. If the shouldSkip method returns false, the @Conditional reference will be decoded and set, else it will be skipped.

*Using Custom Serializers*

By default FST falls back to the methods defined by the JDK. Especially if private methods like 'writeObject' are involved, performance suffers, because reflection must be used. Additionally the efficiency of some stock JDK classes is _cruel_ regarding size and speed. The FST default configuration ({{{FSTConfiguration.createDefaultConfiguration()}}}) already registers some serializers for common classes (popular Collections and some other frequently used classes).
So if you have trouble with stock JDK serilaization speed/efficiency, you might want to register a piece of custom code defining how to read and write an object of a specific class.

the basic interface to define the serialization of an Object is {{{FSTObjectSerializer}}}. However in most cases you'll use a subclass of {{{FSTBasicObjectSerializer}}}.

The FSTDateSerializer delivered with FST (note the registration in the instantiate method, you need to do it if you instantiate the object by yourself):
{{{
public class FSTDateSerializer extends FSTBasicObjectSerializer {
    @Override
    public void writeObject(FSTObjectOutput out, Object toWrite, FSTClazzInfo clzInfo, FSTClazzInfo.FSTFieldInfo referencedBy) 
    {
        out.writeFLong(((Date)toWrite).getTime());
    }

    @Override
    public void readObject(FSTObjectInput in, Object toRead, FSTClazzInfo clzInfo, FSTClazzInfo.FSTFieldInfo referencedBy)
    {
    }

    @Override
    public Object instantiate(Class objectClass, FSTObjectInput in, FSTClazzInfo serializationInfo, FSTClazzInfo.FSTFieldInfo referencee, int streamPositioin) 
    {
        Object res = new Date(in.readFLong());
        in.registerObject(res,streamPositioin,serializationInfo);
        return res;
    }
}
}}}

a serializer is registered at the {{{FSTConfiguration}}} Object:
{{{
   ...
   conf = FSTConfiguration.createDefaultConfiguration();     
   conf.registerSerializer(Date.class, new FSTDateSerializer(), false);
   ...
}}}

(ofc you have to use exactly this configuration later on in the {{{FSTObjectIn/OutputStream}}})