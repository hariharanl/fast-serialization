<p lign=right>_FST - Fast Serialization Thingy_</p>
----
==Optimization==


FST defines a set of annotations which influence the en/decoding of objects at runtime. Note that default FST (no annotations) is optimized the most. So prepare for a tradeoff speed <=> serialization size. However frequently it is more important to minimize the size of an object bandwith considerations, further processing (remoting in a cluster) etc.

FST has some utility methods which let you measure the effects of your optimization:

{{{
FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
// .. register some serializers etc.
YourObjectToSerialize ex = new YourObjectToSerialize(); // <= annotate this or not

System.out.println("Size:"+conf.calcObjectSizeBytesNotAUtility(ex));   
System.out.println("Write:"+conf.calcObjectWriteTimeNotAUtility(1000000, ex));
System.out.println("Read:"+conf.calcObjectReadTimeNotAUtility(1000000, ex));
}}}

Note that these methods are not intended for usage at runtime ever ! The times are given in picoseconds else it would be hard to measure the duration of small objects. In case you test smallish Objects (e.g. 5..10 variables, no collections) consider creating a temporary array of 50 or so instances of your object, else the measuring will be skewed by the time required to initialize the objectstreams itself. However if you play around with {{{@EqualnessIsBinary}}} this might skew the Object size :).

*{{{@Compress}}}*

The compress annotation lets FST do moderate compression on the annotated field.
It is currently aknowledged only for Strings and integer arrays.


For Strings an attempt is made to squeeze 2 chars into a byte .. this works good for plain text containing small caps. Don't use it for large caps-only Strings. For normal english strings expect a saving of 10..30%. Note that the String should at least have >12 chars to make this effective. The performance hit for this compression is moderate (far lower than a real compression algorithm). It is guaranteed that the string will not grow in size due to compression, you only have a small performance hit in string writing then (<10%).


For integer arrays a detection is done wether one of the following algorithms succeeds in reducing the size:

  * compact int - codes small numbers in 1..3 bytes, but large in 5
  * thin int array - successfull if you have a lot of '0' values in a int array
  * diff int - successful if your integer array contains little volatility (e.g. chart data). Only the first value is written, after that only the difference to the next value is written.
  * offset int - computes min an max of the int array. In case the range is < 65535, the min value and a series of short's is written.

*{{{Conditional}}}*

see QuickStart page

*{{{EqualnessIsBinary}}}*


*{{{EqualnessIsIdentity}}}*


*{{{Flat}}}*


*{{{Plain}}}*


*{{{Predict}}}*


*Thin*