<p lign=right>_FST - Fast Serialization Thingy_</p>
----
==Optimization==


FST defines a set of annotations which influence the en/decoding of objects at runtime. Note that default FST (no annotations) is optimized the most. So prepare for a tradeoff speed <=> serialization size. However frequently it is more important to minimize the size of an object bandwith considerations, further processing (remoting in a cluster) etc.

FST has some utility methods which let you measure the effects of your optimization:

{{{
FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
// .. register some serializers etc.
YourObjectToSerialize ex = new YourObjectToSerialize(); // <= annotate this or not

System.out.println("Size:"+conf.calcObjectSizeBytesNotAUtility(ex));       System.out.println("Write:"+conf.calcObjectWriteTimeNotAUtility(1000000, ex));
System.out.println("Read:"+conf.calcObjectReadTimeNotAUtility(1000000, ex));
}}}

Note that these methods are not intended for usage at runtime ever ! The times are given in picoseconds as else it would be hard to measure the duration on serializing small objects. In case you test smallish Objects (e.g. 5..10 variables, no collections) consider creating a temporary array of 50 or so instances of your object, else the measuring will be skewed by the time required to initialize the objectstreams itself.

*{{{@Compress}}}*

The compress annotation lets FST do moderate compression on the annotated field.
It is currently aknowledged only for Strings and integer arrays.


*{{{Conditional}}}*


*{{{EqualnessIsBinary}}}*


*{{{EqualnessIsIdentity}}}*


*{{{Flat}}}*


*{{{Plain}}}*


*{{{Predict}}}*


*Thin*