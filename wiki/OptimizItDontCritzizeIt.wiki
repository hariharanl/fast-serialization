<p lign=right>_FST - Fast Serialization Thingy_</p>
----
==Optimization==


FST defines a set of annotations which influence the en/decoding of objects at runtime. Note that default FST (no annotations) is optimized the most. So prepare for a tradeoff speed <=> serialization size. However frequently it is more important to minimize the size of an object bandwith considerations, further processing (remoting in a cluster) etc.

FST has some utility methods which let you measure the effects of your optimization:

{{{
FSTConfiguration conf = FSTConfiguration.createDefaultConfiguration();
// .. register some serializers etc.
YourObjectToSerialize ex = new YourObjectToSerialize(); // <= annotate this or not

System.out.println("Size:"+conf.calcObjectSizeBytesNotAUtility(ex));   
System.out.println("Write:"+conf.calcObjectWriteTimeNotAUtility(1000000, ex));
System.out.println("Read:"+conf.calcObjectReadTimeNotAUtility(1000000, ex));
}}}

Note that these methods are not intended for usage at runtime ever ! The times are given in picoseconds else it would be hard to measure the duration of small objects. In case you test smallish Objects (e.g. 5..10 variables, no collections) consider creating a temporary array of 50 or so instances of your object, else the measuring will be skewed by the time required to initialize the objectstreams itself. However if you play around with {{{@EqualnessIsBinary}}} this might skew the Object size :).




*{{{@Compress}}}*

The compress annotation lets FST do moderate compression on the annotated field.
It is currently aknowledged only for Strings and integer arrays.


For Strings an attempt is made to squeeze 2 chars into a byte .. this works good for plain text containing small caps. Don't use it for large caps-only Strings. For normal english strings expect a saving of 10..30%. Note that the String should at least have >12 chars to make this effective. The performance hit for this compression is moderate (far lower than a real compression algorithm). It is guaranteed that the string will not grow in size due to compression, you only have a small performance hit in string writing then (<10%).


For integer arrays a detection is done wether one of the following algorithms succeeds in reducing the size:

  * compact int - codes small numbers in 1..3 bytes, but large in 5
  * thin int array - successfull if you have a lot of '0' values in a int array
  * diff int - successful if your integer array contains little volatility (e.g. chart data). Only the first value is written, after that only the difference to the next value is written.
  * offset int - computes min an max of the int array. In case the range is < 65535, the min value and a series of short's is written.



*{{{@Conditional}}}*

see QuickStart page



*{{{@EqualnessIsBinary}}}*

This option may greatly reduce the size of the serialized Objects. In todays enterprise application one frequently has value type objects such as {{{Person { name, prename, age, id } }}} or {{{ValuePair { int key, String value } }}}. Frequently these objects result from some generated data source  abstraction layer such as Hibernate or some homegrown generated stuff.
Unfortunately often you get several instances for the same business object. Example you have 2 Person objects which are equal in all their field values.

FST can detect those double instances during serialization and manages to write only one instance. At deserialization time, the {{{InputStream }}} is "rewinded" and the single copy is read several times, so at read time you get an exact copy of the object graph you serialized.

Since this consumes some CPU-time, only for classes tagged with {{{EqualnessIsBinary}}} a equalness detection is performed. Note that you have to implement equals and hashCode correctly to have this work. Also not if the equals method does not cover all fields of a class, you may get wrong results upon deserializing.

Example:
{{{
@EqualnessIsBinary
public class ObjectOrientedDataType implements Serializable {

    // encapsulate like a boss
    @Compress
    private String aString="";
    private boolean isCapableOfDoingAnythingMeaningful;
    public ObjectOrientedDataType() {}

    public ObjectOrientedDataType(String valueString) {
        if ( valueString == null ) {
            isCapableOfDoingAnythingMeaningful = false;
            aString = "";
        } else {
            this.aString = valueString;
        }
    }

    public boolean equals( Object o ) {
        if ( o instanceof ObjectOrientedDataType) {
            ObjectOrientedDataType dt = (ObjectOrientedDataType) o;
            return dt.aString.equals(aString) 
                && dt.isCapableOfDoingAnythingMeaningful == isCapableOfDoingAnythingMeaningful;
        }
        return super.equals(o);
    }

    public int hashCode() {
        return aString.hashCode();
    }

    public String toString() {
        return aString;
    }
}
}}}


*{{{EqualnessIsIdentity}}}*


*{{{Flat}}}*


*{{{Plain}}}*


*{{{Predict}}}*


*Thin*